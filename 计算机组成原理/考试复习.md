# 计组复习



## 第一章 概论

### 计算机硬件构成

运算器、存储器、控制器、总线、输入输出设备（也就是I/O设备、外围设备）、适配器（I/O接口）

计算机硬件系统由存储系统、CPU、总线、输入输出系统组成

### 软件的分类

系统程序（包括：各类服务性程序，语言程序，操作系统，数据库管理系统）、应用程序

### 软件发展演变

目的程序、汇编程序、源程序、操作系统、数据库管理系统

### 计算机系统层次结构

微程序设计级→机器语言级→操作系统级→汇编语言级→高级语言级



## 第二章 运算方法和运算器

### 补码与补码加减法

补码减法：`[x-y]补=[x+(-y)]补=[x]补+[-y]补`，其中`[-y]补`为`[y]补`的机器负数（含符号位一起变反）

![image-20200517102844313](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517102827662.png?raw=true)

溢出判断可使用双符号位判断，正数为00，负数为11。变形补码的两个符号位都可以参与运算，运算结果根据两个符号位是否一致来判断是否溢出。



### 定点整数与定点小数的范围

原码表示时的范围（同反码）

* 整数：`-(2^n - 1)<=X<=(2^n - 1)`

* 小数：`-(1 - 2^-n)<=X<=(1 - 2^-n)`

补码表示时的范围（同移码）

* 整数：`-(2^n)<=X<=(2^n -1)`
* 小数：`-1<=X<=(1-2^(-n))`



### 运算器的硬件构成

要求：掌握硬件结构上补码的除法运算乘法运算的硬件构成，不要求画，要懂得计算阵列形式

* 不恢复余数阵列除法器核心部件：CAS
* 计算`N*N`乘法计算需要`N*(N-1)`个加法器
* 1位加法器：Si时延6T, Ci+1时延5T，n位加法器(2n+9)T

4位并行进位加法器需要4个的函数发生器和1个先行进位逻辑，16位则由4个四位并行进位加法器串联组成，还另外需要1个组间先行进位逻辑

![image-20200517103036484](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517103036484.png?raw=true)

构成128位的先行进位加法器需要多少个运算部件和先行进位部件？？

流水线加法器技术参数计算：可参考第二章PPT，P101~102



### 定点数除法

1. 定点数除法时通过减法依次比较被除数和除数，判定商，够减时q=0（也可从余数的符号位来判断商的数值）
2. 计算时先算好除数被除数的补码、以及被除数的相反数的补码，每做一次运算时除数右移一位。
3. 在恢复余数除法器下，不够减则回加余数恢复A；若在不恢复余数除法器，则根据余数符号位决定下一次做`A+B->A`还是`A-B->A`，最后一步特殊处理，若q=0则需要恢复余数
4. 被除数的数值部分，尾数的长度需是2倍的除数长度

#### 例：恢复余数除法运算及流程

![image-20200517103407625](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517103407625.png?raw=true)

#### 例：不恢复余数除法运算及流程

![image-20200517103508086](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517103508086.png?raw=true)

![image-20200517103157576](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517103157576.png?raw=true)

### 浮点数表示法

![image-20200517102747958](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517102747958.png?raw=true)

浮点数的表示，三种形式（IEEE754标准，题目给出的，通常情况下阶码按移码表示）

1. 规格化浮点数：`(-1)^S * 1.M * 2^e`——`e`是指数，`E`是阶码，用原码表示尾数时尾数域最高位需为1，用补码表示尾数时，尾数域的最高位（小数点后第一位）需和符号位相反

2. IEEE754标准下：尾数部分用规格化小数表示，阶码`E`用隐含移码表示，计算公式`E=e+127/1023`，`E`的范围1~254，但`e`的范围-126~127

   | 范围     | 二进制表示                         | 数值表示                         |
   | -------- | ---------------------------------- | -------------------------------- |
   | 最大正数 | 0 11111111 11111111111111111111111 | `2^(2^7 - 1) * (1 - 2^(-23))`    |
   | 最小正数 | 0 00000000 10000000000000000000000 | `2^(-2^7) * (2^(-1))`            |
   | 最大负数 | 1 00000000 01111111111111111111111 | `-2^(2^-7) * (2^(-1) + 2^(-23))` |
   | 最小负数 | 1 11111111 00000000000000000000000 | `2^(2^7 - 1) * (-1)`             |





## 第三章 内部存储器

### SRAM/DRAM区别

SRAM：用双稳态触发器保存信息，集成度低、功耗大、速度慢

DRAM：利用记忆电容保存信息，需要定时刷新（再生读出），集成度高、功耗低

### 高性能DRAM

FPM-DRAM：快速页模式动态存储器

CDEAM：带cache的动态存储器——DRAM里集成一个小SRAM

SDRM：DRAM基础上增加一个时钟信号，使得对数据读取和系统时钟同步

### 内存扩展

#### 位（字长）扩展

* 各芯片地址线、控制线公用。**数据线单独分开**

* 所需芯片数d=设计要求的存储器容量/已知芯片的储存容量

#### 字（存储容量）扩展

* 芯片地址线、数据线公用，R/W公用。**片选通过高位地址译码控制**
* 所需芯片数d=设计要求的存储器容量/已知芯片的储存容量
* **算出系统存储容量所需地址数A1，芯片地址数A2，A1-A2得出高位地址数**
* 芯片按高低顺序编号，分配高位地址数值
* 高位地址译码后分别控制芯片的片选信号

#### 字位扩展

* 以用1Kx4芯片组成4Kx8为例：

  ![image-20200517103713111](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517103713111.png?raw=true)

* `(4Kx8)` / `(1Kx4)` = `(4x2)`

* 位扩展：先将2个`(1Kx4)`芯片组合起来作为位扩展，变成`(1Kx8)`。扩展时数据线(I/O)分两条：`D7~D4`连第一条，`D3~D0`连第二条。地址线公用，控制线(CS)公用

* 字扩展：然后将上述的芯片组`(1Kx8)`拿4组进行字扩展，4组=2^2，需要2位的片选信号，原芯片`(1Kx4)`有12位地址，将`A11~A10`作为片选信号，连接到`2-4译码器`控制各自芯片组的CS。四组之间芯片地址线公用、两条数据线分别公用

| A11  | A10  | A11~A0    | 片选对应的芯片 |
| ---- | ---- | --------- | -------------- |
| 0    | 0    | 000~3FF   | S11 S12        |
| 0    | 1    | 400~7FF   | S21 S22        |
| 1    | 0    | 800~8FF   | S31 S32        |
| 1    | 1    | 0C00~0FFF | S41 S42        |

例二：![image-20200517104119338](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517104119338.png?raw=true)

![image-20200517104153061](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517104153061.png?raw=true)

![image-20200517104135391](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517104135391.png?raw=true)

### DRAM刷新操作

刷新方式：各芯片同时、片内按行

最大刷新周期：2ms、8ms、16ms等

（1）集中刷新：在最大刷新周期内集中安排所有刷新周期

（2）分散刷新：各刷新周期分散安排在存取周期中

（3）异步刷新：各刷新周期分散安排在最大刷新周期内，计算提交刷新请求的间隔时间：最大刷新周期/行数

### 并行存储器

并行存储器的两类：

* 双端口存储器：一个存储器有两组读写控制线（地址线、数据线、控制线），它们相互独立

  双端口存储区的读写有两种情况：

  1. 无冲突读写控制：两个端口地址不冲突
  2. 有冲突读写控制：两个端口同时读写同一存储单元

* 多模块交叉存储器：存储器由若干个模块组成，对存储器的寻址采用交叉方式操作，每个模块地址线、数据线和控制线独立，采用交叉编址方式，同时访问多个存储器

  相关计算：交叉存储器连续读`m`个字的时间：`T1=T+(m-1)t`。其中存取周期为`T`，总线传送周期为`t`，模块数为`m`。而顺序存储器连续读`m`个字需要的时间`T2=mT`。

与顺序存储器的区别：

* 顺序存储器存取信息时，只能按存储单元的位置，顺序地一个接一个地进行存取的存储器。最典型的是磁带存储器。
* 而并行存储器可以同时访问多个存储器，用交叉的方式来进行存储器寻址。

### Cache和主存地址映射方式

前置知识点：

* CPU与主存之间，以字为单位交换信息
* CPU与Cache之间，以字为单位交换信息
* Cache与主存之间，以块为单位交换信息（一个块包含若干个字）
* 主存划分`2^s`个块，每块`2^w`个字。Cache分为`2^r`个行，**Cache每行的大小=主存每块的大小**

解题：

* 拿到题目可根据`Cache容量/行大小`得出Cache行数`2^r`，计算出`r`。Cache的行大小等于主存的块大小，因此主存的块数为`主存容量/行大小=2^s`，计算出`s`。给出存储行数`2^r`和每组行数`v=2^v'`，可计算组数`u=2^d`，根据组数`2^d`得出组号需要`d`位来表示，组内行号需要`r`位表示，行内地址需要`w`位表示····
* 再根据映射规则写出映射表



#### 全相联映射方式

主存中每个块可复制到任一行的Cache行中，块号地址存于标记（用于标记当前行对应主存的哪个块）

检索步骤：将块号与所有标记依次进行比较，命中，则根据块（行）内地址从Cache中读取该字；否则，CPU从主存中读取。

主存地址格式：块号`s`位 | 行、块内字地址`w`位

#### 直接映射方式

主存与Cache的划分方式同全相连。主存中每个块只能**按对应关系(i = j mod r)**复制到**固定的**Cache里的某一行中，块号高位地址存于标记

| Cache存储器行数 | 主存块                                                    |
| --------------- | --------------------------------------------------------- |
| 0               | 0,         2^r,            2^(r+1),       ... , 2^s - 2^r |
| 1               | 1,         2^r + 1,     2^(r+1) +2, ... , 2^s - 2^r + 1   |
| 2^r - 1         | 2^r -1, 2^(r+1) -1, 2^(r+2) -1, ... , 2^s -1              |

块号(0, 1, ... ,2^r -1)分别对应Cache中的存储行(0, 1, ... ,2^r -1)

块号(2^r, 2^r + 1, ... ,2^(r+1) -1)分别对应Cache中的存储行(0, 1, ... ,2^r -1)

主存块中分别有(2^s / 2^r)个块被映射到Cache中的同一行

主存地址格式：Tag`(s-r)`位 | 行号`r`位 | 块内地址`w`位

Cache地址格式： 行号`r`位 | 行内地址`w`位

行标记容量：`2^r * len(Tag)`

![image-20200517104421727](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517104421727.png?raw=true)

#### 组相联映射方式

组间直接映射，组内全相联映射，兼有全相连及直接相连的优点

Cache分为`u (2^d)`个组，每组有`v (2^v')`行，即`r = d+v'`。主存拥有`2^s / u`个组，**主存中每组的块数 = Cache中的组数u**，**主存中的各块与Cache的组号有固定的映射关系**，可自由映射到对应的Cache组中的任何一行

| Cache的组号                                   | 主存块                                      |
| --------------------------------------------- | ------------------------------------------- |
| 0组（行0, 1, 2, ... , v）                     | 0,     u,     2u,      3u,     ... ,2^s - u |
| 1组（行v+1, v+2, ... , 2v）                   | 1,     u+1, 2u+1, 3u+1, ... ,2^s - u + 1    |
| 2组（行2v+1, 2v+2, ... , 3v）                 | 2,     u+2, 2u+2, 3u+2, ... ,2^s - u + 2    |
| u-1组（行2^r - v, 2^r - v +1, ... , 2^r - 1） | u-1,  2u-1, 3u-1, 4u-1, ... ,2^s - 1        |

块号(0~u-1)为主存中的第0组，主存第0组中的每块(0, 1, 2, ... ,u-1)分别对应Cache中每组(0, 1, 2, ... ,u-1)。

块号(u~2u-1)为主存中的第1组，主存第1组中的每块(u, u+1, u+2, ... ,2u-1)分别对应Cache中每组(u, u+1, u+2, ... ,2u-1)。

主存地址格式：Tag`(s-d)`位 | Cache组号`d`位 | 块内地址`w`位

Cache地址格式：组号`d`位 | 组内行号`v'`位 | 行内地址`w`位

页标记容量：`v * len(Tag) ` 

![image-20200517104452591](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517104452591.png?raw=true)



### Cache效率计算

1. 命中率`h = Nc/(Nc+Nm)` ：`Nc`为cache完成存取的总次数，`Nm`为主存完成存取的总次数
2. 存储系统的平均访问时间`ta = h*tc + (1-h)*tm`：`tc`为命中的cache访问时间，`tm`为未命中的主存访问时间
3. 效率`e = tc/ta`

例题：

![image-20200517104726554](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517104247552.png?raw=true)

### 内存读写周期图形

![image-20200517103628998](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517103628998.png?raw=true)

## 第四章 指令系统

### 基本概念

指令系统：一台计算机所有机器指令的集合，代表了一台计算机的硬件功能

* CISC——复杂指令系统
* RISC——精简指令系统

指令由操作码和地址码组成

根据指令中有几个操作数可分成三地址、二地址、一地址和零地址几种结构形式

零地址不含地址码，可能是不需要操作数的指令或操作数已经隐含指定。

一地址可能是单操作数的指令`OP (A) -> A`或是双操作数的指令`(AC) OP (A) -> AC`，在双操作数的例子中使用了隐地址，AC是隐含约定

二地址根据操作数的物理位置可分为：

* 存储器-存储器（SS）型：参与操作的数都放在内存里。
* 寄存器-寄存器（RR）型：参与操作的数都放在寄存器里。
* 寄存器-存储器（RS）型：一个操作数在内存，一个在寄存。

三地址指令：`(A1) OP (A2) -> A3`

操作数的寻址方式说明形成操作数的有效地址的方法，含义有二，一是表示操作数在哪（如在寄存器中或主存单元中）；二是要给出获取操作数地址的方法。

指令格式 操作码OP | 寻址模式X | 间址标志I | 形式地址A

* 隐含寻址：操作数的地址隐含在操作码中，不访问存储器
* 立即寻址：直接给出操作数，不访问存储器
* 直接寻址：直接给出操作数地址，根据该地址从主存中取操作数
* 间接寻址：给出存放操作数地址的主存单元地址，先去主存中的指定位置取出操作数地址，再根据操作数地址去取数
* 寄存器寻址：指令中给出寄存器号（也称寄存器地址），从寄存器中获取操作数
* 寄存器间接寻址：操作数在主存单元中，由指令给出寄存器号，该寄存器存放操作数地址
* 偏移寻址：有效地址由寄存器内容加一偏移量组成，分为相对寻址、基址寻址、变址寻址、段寻址、堆栈寻址



### 分析指令特征与构成

1. 指出指令的字长，单字长/双字长等等。`1 * WORD`= `2 * BYTE` = `16 * BIT`，分析指令类型(SS/RR/RS)，以及操作数的寻址方式

   例题：某16位机器所使用的指令格式和寻址方式如下所示，该机有两个20位基址寄存器，四个16位变址寄存器，十六个16位通用寄存器，指令汇编格式中的S（源），D（目标）都是通用寄存器，M是主存中的一个单元。三种指令的操作码分别是MOV（OP）＝（A）H ，STO（OP）＝（1B）H ，LDA（OP）＝（3C）H。MOV是传送指令，STO为存数指令，LDA为取数指令。 
   要求： （1）分析三种指令的指令格式与寻址方式特点。（2）CPU完成哪一种操作所花时间最短？哪一种操作所花时间最长？第二种指令的执行时间有时会等于第三种指令的执行时间吗？（3）下列情况下每个十六进制指令字分别代表什么操作？其中如果有编码不正确，如何改正才能成为合法指令？
   ①(F0F1)H (3CD2)H  ②(2856)H ③(6FD6)H ④(1C2)H

   ![image-20200517104922552](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517104922552.png?raw=true)

   解：

   （1）第一种指令是单字长二地址指令，RR型；第二种指令是双字长二地址指令，RS型，其中S采用基址寻址或变址寻址，R由源寄存器决定；第三种也是双字长二地址指令，RS型，其中R由目标寄存器决定，S由20位地址（直接寻址）决定。
   （2）处理机完成第一种指令所花时间最短，因为是RR型指令，不需要访问存储器。第二种指令所花时间最长，因为是RS型指令，需要访问存储器，同时要进行寻址 方式的变换运算（基址或变址），这也需要时间。第二种指令的执行时间不会等于第三种指令，因为第三种指令虽然也访问存储器，但节省了求有效地址运算的时间 开销。

   （3）据已知条件：MOV（OP）＝001010，STA（OP）＝011011，LAD（OP）＝111100,将指令的十六进制格式转换成二进制代码且比较后可知：

   * （F0F1）H （3CD2）H 指令代表LAD指令，编码正确，其含义是把主存（13CD2）H 地址单元的内容取至15号寄存器。
   * （2856)H 指令代表MOV指令，编码正确，含义是把6号源寄存器的内容传送至5号目标寄存器。 
   * （6FD6）H ＝ 0110 1111 1101 0110，是单字长指令，一定是MOV指令，但编码错误，可改正为（28D6）H
   * （1C2）H 是单字长指令，代表MOV指令，但编码错误，可改正为（28C2）H 。 

   

2. 分析指定的操作码字段可以设计多少条指令，指令有几个地址码，地址码所能表示的地址范围和其物理位置

   ![image-20200517105225117](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517105225117.png?raw=true)

3. 根据指令格式和有效地址算法写出对应的寻址方式

   ![image-20200517104844616](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517104844616.png?raw=true)



## 第五章 中央处理器

压轴题在第五章，题型是给CPU结构分析指令对应的微程序和指令流程图



### 基本概念

![image-20200517102121522](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517102121522.png?raw=true)

CPU的基本组成：

* 运算器：实现数据的算术与逻辑运算
* **控制器：控制器产生控制信号，协调指挥各个部件完成执行指令的操作（取值、译码或测试、控制数据流动）**
* Cache：存储指令和数据

CPU模型的几个组件：

* 地址寄存器（AR）：存储当前访问的数据的地址

* 数据缓冲寄存器（DR）：存储运算结果和缓冲CPU与外部数据传送
* 指令寄存器（IR）：存储当前正在执行的**指令字**
* 指令译码器：**分析测试**指令**操作码**的功能
* 程序计数器（PC）：存储下一条要**执行指令的地址**
* 状态字寄存器（PSW）：存储**运算状态**
* 通用寄存器（R0~R3）：存储参与运算及运算结果的数据。
* 指令总线（IBUS），数据总线（DBUS），地址总线（ABUS），RS-BUS，ALU-BUS，ALU，数存，指存
* 开关：LDDR, LDAR, LDPC ——置1时则从总线上加载数据到对应寄存器



### 分析指令周期

![image-20200517102025437](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517102025437.png?raw=true)

CPU的工作就是**周而复始的执行指令**过程，指令分段过程包含：取指令、分析指令、执行指令（细分为取操作数、执行操作、形成下一条指令的地址）

一个指令周期包含若干CPU周期（也称作机器周期），CPU周期用**从内存读取一条指令字的最短时间**来定义，一个CPU周期包含多个时钟周期，时钟周期是**CPU处理操作的基本时间单位**，通常称为节拍脉冲或T周期。

——基本的指令周期：取指周期+执行周期，执行任一指令**至少**需要2个CPU周期

| 指令助记符   | 功能               | 描述               | CPU周期数 |
| ------------ | ------------------ | ------------------ | --------- |
| `MOV R0, R1` | 寄存器数据传送     | `(R1) → R0`        | 2         |
| `LAD R1, 6`  | 从内存取数到寄存器 | `(6) → R1`         | 3         |
| `ADD R1, R2` | 加法操作           | `(R1) + (R2) → R2` | 2         |
| `STO R2, R3` | 存寄存器数据到内存 | `(R2) → (R3)`      | 3         |
| `JMP 101`    | 无条件转移         | `101 → PC`         | 2         |
| `AND R1, R3` | 逻辑与操作         | `(R1) & (R3) → R3` | 2         |

![image-20200517102636887](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517102636887.png?raw=true)

每个指令执行之前，都要**取指、译码**的过程。这个过程占了**一个**CPU周期。其中取值的详细过程是：

* `PC→ABUS(I)`：PC寄存器把目前要执行的指令的地址送到ABUS(I)上，
* `IBUS→IR`：从ABUS(I)收到地址，再去指存里的相应地址取出指令通过指令总线IBUS送到指令寄存器IR里
* `PC+1`

**执行STO指令时，需要3个指令周期：**

1. 取指+译码 ——占一个指令周期
2. `R3→AR` ——寄存器R3中存放的是要写入的内存地址，将R3的数据取出送到AR。占一个指令周期。
3. `R2→DBUS` ——R2是存放要写入的数据，读出R2的数据送到DBUS，占一个指令周期。

**执行LAD指令时，需要3个指令周期：**

1. 取指+译码 ——占一个指令周期
2. `IR(A)→AR` ——指令寄存器中的操作数部分是要取的数的内存地址，将其取出送到AR。占一个指令周期。
3. `AR→ABUS`, `DBUS→DR`, `DR→R1` ——从内存取数通过DBUS送到DR上，再从DR写入数据到R1。共占一个指令周期

**执行JMP指令时，需要2个指令周期：**

1. 取指+译码 ——占一个指令周期
2. `IR(A)→PC` ——将IR中的操作数A送到PC。占一个指令周期。

**执行ADD指令时，需要2个指令周期：**

1. 取指+译码 ——占一个指令周期
2. `R1+R2→DR`, `DR→R2` ——R1,R2经过ALU进行加法运算，结果通过DBUS传回DR，再将DR的数据写入R2。共占一个指令周期。





### 控制器与时序产生

操作控制器：根据指令操作码和时序信号，产生各种控制信号，在各寄存器之间建立数据通路

时序产生器：产生定时信号，对各种操作信号实施时间上的控制。

常用控制器时序方式：

* 硬布线控制器：采用主状态周期——节拍电位——节拍脉冲三级体制。

* 微程序控制器：采用节拍电位——节拍脉冲二级体制。



### 分析微程序执行流程

#### 基本术语

* 微命令：控制部件通过控制线向执行部件发出的**各种控制信号**。

* 微操作：执行部件**接受微命令后所进行的操作**。

  ——相斥性微操作：不能同时或在同一个CPU周期中出现的微操作。

  ——相容性微操作：能同时或在同一个CPU周期中出现的操作。 

* **微指令：** 在机器的**一个CPU周期**中，一组实现一定操作功能的**微命令的组合**。

* **微程序： 实现一条机器指令功能的许多条微指令组成的序列。**

——微指令给出的控制信号都是**节拍电位**信号， 部分微命令还要和**节拍脉冲信号相与**。

#### 微程序控制原理

* 将**1个CPU周期**内要发出的**控制信号**编成**微指令**，这样**每条机器指令**的所有操作可以编成**一段由微指令组成的微程序**；
* 然后将所有机器指令的微程序存到一个只读存储器——也就是控制存储器（CM）里
* 如此一来：CPU执行一条指令时，只需将CM中相应的一段微程序读出来，执行该段微程序，就可产生各种微操作信号，以实现该指令的功能。

#### 微程序控制器组成原理

![image-20200517102234698](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517102234698.png?raw=true)

1. 控制存储器：用于存放实现全部指令系统的微程序。
2. 微指令寄存器： 用来存放当前执行的一条微指令。
3. 地址转移逻辑： 用于形成下条微指令的微地址。



#### 微指令格式

* 微操作控制字段（1~17）：产生**控制信号**

  | 1       | 2       | 3       | 4      | 5      | 6      | 7      | 8      | 9      | 10   | 11   | 12   | 13    | 14      | 15      | 16      | 17     |
  | ------- | ------- | ------- | ------ | ------ | ------ | ------ | ------ | ------ | ---- | ---- | ---- | ----- | ------- | ------- | ------- | ------ |
  | `LDR1'` | `LDR2'` | `LDR3'` | `R1→X` | `R2→Y` | `R2→X` | `R2→Y` | `DR→X` | `R3→Y` | `+`  | `M`  | `-`  | `RD'` | `LDDR'` | `LDIR'` | `LDAR'` | `PC+1` |

  M：ALU逻辑运算开关，X,Y：ALU的两个输入端，LDRX'：从ALU-BUS总线加载数据到到RX

  +/-：ALU加减控制

* 顺序控制字段（18~23）：产生**下条微指令的地址**

  | 18   | 19   | 20~23    |
  | ---- | ---- | -------- |
  | `P1` | `P2` | 直接地址 |

  当测试位18~19为`00`，由20~23直接指示后继地址；任意测试位为`1`，说明要进行相应测试，根据测试结果对20~23的某一位或几位进行修改，最终形成后继地址

![image-20200517102323423](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517102207111.png?raw=true)



#### 微程序分析及例题



![image-20200517102406420](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517102406420.png?raw=true)

| CM地址 | 执行的指令           | 对应的微程序格式中为1的字段 | 微程序编码                       |
| ------ | -------------------- | --------------------------- | -------------------------------- |
| 0000   | `PC→M`,`M→IR`,`PC+1` | `RD`, `LDIR`,`PC+1`         | 000 000 000 000 10101 \| 10 0000 |
| -      | `TEST P1`            | -                           |                                  |
| 1010   | `R1+R2→R2`           | `R1→X`,`R2→Y`,`+`,`LDR2`    | 010 100 100 100 00000 \| 00 1001 |
| 1001   | `R2+R3→R2`           | `R2→X`,`R3→Y`,`+`,`LDR2`    | 010 001 001 100 00000 \| 01 0000 |
| -      | `TEST P2`            | -                           |                                  |
| 0001   | `R2-R3→R2`           | `R2→X`,`R3→Y`,`-`,`LDR2`    | 010 001 001 001 00000 \| 00 0000 |

例题：PPT 第五章 P21

![image-20200517101945436](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517101945436.png?raw=true)

#### 微指令形成方式及例题

1. 计数器方式（增量）

   **顺序执行**时，后继地址在**现行微地址上加上一增量**；**非顺序**执行时，需执行一条**转移微指令**。

   优点：顺序控制字段较短，设计简单。缺点：多路并行转移弱，速度较慢，灵活性差。

2. 多路转移方式（断定）

   将顺序控制字段分成**测试字段（P）**和**下地址字段**二段。

   未出现多路分支时， 后继由下地址字段直接给出；出现多路分支时，根据**测试字段值和状态条件**选择转移地址。

   优点：多路转移灵活，速度快；缺点：转移地址硬件设计复杂。

   注意点：

   * **直接地址字段**的长度，要保证在未出现多路分支时，**寻址范围**能覆盖整个控制存储器（CM）

   * 出现**多路分支**时，转移地址由微地址转移逻辑产生。**微地址转移逻辑**的**输入来源**一般包括：
     *  微指令中的测试字段、下地址
     *  指令的操作码
     *  执行部件的状态标志

   * 当微地址转移逻辑要进行测试时：

     一般地，对**n位**的**状态标志**（或是**操作码**）进行某一种测试P，最终会**相应地对uAR中的n位进行修改，则最多可产生2^n种分支地址**。

   

   **例题**

   1. 微地址寄存器有6位(μA5-μA0)，当需要修改其内容时，可通过某一位触发器的强置端S将其置“1”。现有三种情况，按多路转移方法设计微地址转移逻辑：

      (1) 执行“取指”微指令后，微程序按IR的OP字段(IR3-IR0)进行16路分支；

      (2) 执行条件转移指令微程序时，按进位标志C的状态进行2路分支；

      (3) 执行控制台指令微程序时，按IR4，IR5的状态进行4路分支。

      解答：

      P1~P3分别对应题目所述的(1)~(3)三种情况：

      * (1) 用P1和IR3-IR0修改μA3-μA0；(2) 用P2和C修改μA0；(3) 用P3和IR5，IR4修改μA5，μA4。

      若修改地址必须在T4时钟的上升沿，则可有：

      | μA5         | μA4         | μA3         | μA2         | μA1         | μA0                   |
      | ----------- | ----------- | ----------- | ----------- | ----------- | --------------------- |
      | `P3·IR5·T4` | `P3·IR4·T4` | `P1·IR3·T4` | `P1·IR2·T4` | `P1·IR1·T4` | `P1·IR0·T4 + P2·C·T4` |

   2. 某机器微地址寄存器有5位(μA4-μA0)；指令系统共包含+、-、*、/ 4种操作，由指令中操作码IR5、IR4表示。取指令后，对对IR5、IR4经过P1测试可产生4路分支，分支入口微地址与操作码对应关系如下表，问

      (1) 请按多路转移方法设计微地址转移逻辑。

      (2) 完成取指的微指令中，直接地址字段应设为？

      (3) 若对C进行P2测试，则可能产生几个去向？

      | 操作 | IR5 IR4 | μAR   |
      | ---- | ------- | ----- |
      | +    | 00      | 01100 |
      | -    | 01      | 01101 |
      | *    | 10      | 01110 |
      | /    | 11      | 01111 |

      解答：

      | μA4  | μA3  | μA2  | μA1  | μA0  |
      | ---- | ---- | ---- | ---- | ---- |
      | 0    | 1    | 1    | IR5  | IR4  |

      完成取指的微指令中，直接地址字段应设为`0 1 1 IR5 IR4`

      对C进行P2测试，这里的C即为CF（溢出标志），有0和1两种状态，所以只能产生2个去向



## 第六章 总线系统

没计算题，只出选填简答

### 基本概念

#### 总线的分类

内部总线：CPU内部连接各寄存器及运算器部件之间的总线。 

系统总线：外部总线。CPU和计算机系统中其他高速功能部件相互连接的总线。 

I/O总线：中低速I/O设备相互连接的总线。 

#### 总线的结构

1. 单总线结构：使用一条单一的系统总线来连接CPU、内存和I/O设备。**缺点：某一时间只允许一对设备之间传送数据**

   ![image-20200517115949847](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517115949847.png?raw=true)

   在单总线结构中，要求连接到总线的逻辑部件必须高速运行，以便在某些设备需要使用总线时，能迅速获得控制权；而当不再使用总线时，能迅速放弃总线的控制权。否则，可能导致很大的时间延迟. 

2. 在CPU、主存、I/O之间互联采用多条总线。

   ![image-20200517120118329](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517120118329.png?raw=true)

   多总线结构体现了高速、中速、低速设备连接到不同的总线上同时进行工作，以提高总线的效率和吞吐量，而且处理器结构的变化不影响高速总线。

#### 总线内部结构

早期总线的内部结构如图所示，它实际上是处理器芯片引脚的延伸，是处理器与I/O设备适配器的通道。这种简单的总线一般也由50～100条线组成，这些线按其功能可分为三类：地址线、数据线和控制线。

![image-20200517120553070](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517120553070.png?raw=true)

现代总线结构：

1. 数据传送总线： 由地址线、数据线、控制线组成。
2. 仲裁总线：包括总线请求线和总线授权线。
3. 中断和同步总线：用于处理带优先级的中断操作，包括中断请求线和中断认可线。
4. 公用线： 包括时钟信号线、电源线、地线、系统复位线以及加电或断电的时序信号线等。



![image-20200517120626581](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517120626581.png?raw=true)



实例——Pentium机的总线结构分为三层：CPU总线、PCI总线和ISA总线

#### 总线接口

传输信息采用三种方式：

* 串行传送：串行传送的主要优点是只需要一条传输线，这一点对长距离传输显得特别重要
* 并行传送：并行传送一般采用电位传送。由于所有的位同时被传送，所以并行数据传送比串行数据传送快得多。
* 分时传送：一是采用总线复用方式，某个传输线上既传送地址信息，又传送数据信息。为此必须划分时间片，以便在不同的时间间隔中完成传送地址和传送数据的任务。分时传送的另一种概念是共享总线的部件分时使用总线。

### 总线仲裁

连接到总线上的功能模块有主动和被动两种形态，其中主方可以启动一个总线周期，而从方只能响应主方请求。每次总线操作，只能有一个主方，但是可以有多个从方。 

*——为了解决多个功能模块争用总线的问题，必须设置总线仲裁部件。一般采用优先级或公平策略进行仲裁。* 

按照总线仲裁电路的位置不同，仲裁方式分为**集中式仲裁和分布式仲裁**两种。

*总线占用期：主方持续控制总线的时间。* 



#### 集中式仲裁

集中式仲裁中每个功能模块有两条线连到中央仲裁器：一条是送往仲裁器的总线请求信号线BR，一条是仲裁器送出的总线授权信号线BG。集中式仲裁有三种：链式查询、计数器定时查询、独立请求方式。

1. 链式查询方式

   ![image-20200517150008481](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517150008481.png?raw=true)

   减少总线授权线数量，采用了图所示的**菊花链**查询方式，其中A表示地址线，D表示数据线。BS线为1，表示总线正被某外设使用。 

   链式查询方式的**主要特点**是：总线授权信号BG串行地从一个I／O接口传送到下一个I／O接口。假如BG到达的接口无总线请求，则继续往下查询；假如BG到达的接口有总线请求，BG信号便不再往下查询。这意味着该I／O接口就获得了总线控制权。**缺点**是对询问链的电路故障很敏感。

2. 计数器定时查询方式   

   ![image-20200517150146922](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517150146922.png?raw=true)

   总线上的任一设备要求使用总线时，通过BR线发出总线请求。

   中央仲裁器接到请求信号以后，在BS线为“0”的情况下让计数器开始计数，计数值通过一组地址线发向各设备。当地址线上的计数值与请求总线的设备地址相一致时，该设备置“1”BS线，获得了总线使用权，此时中止计数查询。 

   每次计数可以从“0’开始，也可以从中止点开始。如果从“0’开始，各设备的优先次序与链式查询法相同，优先级的顺序固定。如果从中止点开始，则每个设备使用总线的优先级相等。

3. 独立请求方式

   ![image-20200517152107661](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517152107661.png?raw=true)

   在独立请求方式中，每一个共享总线的设备均有一对总线请求线BR和总线授权线BG；当设备要求使用总线时，便发出该设备的请求信号。

   中央仲裁器中有一个排队电路，它根据一定的优先次序决定首先响应哪个设备的请求，给设备以授权信号BG。 

   独立请求方式比较灵活，它可以预先固定优先级；也可以通过程序来改变优先次序；还可以用屏蔽（禁止）某个请求的办法，不响应来自无效设备的请求。

   因此当代总线标准普遍采用独立请求方式。 对于单处理器系统总线而言，总线仲裁器又称为总线控制器，它是CPU的一部分

#### 分布式仲裁

并行竞争分布式仲裁：

* 总线上的每个设备都有唯一的仲裁号。

* 需要使用总线的设备把“仲裁号”发到仲裁线上

* 发送最大仲裁号的设备将获得总线使用权


### 总线数据传送模式

当代的总线标准大都能支持以下四类模式的数据传送：

1. 读、写操作：读操作是由从方到主方的数据传送；写操作是由主方到从方的数据传送。‘

2. 块传送操作：只需给出块的起始地址，然后对固定块长度的数据一个接一个地读出或写入。

3. 写后读、读修改写操作：这是两种组合操作。只给出地址一次（表示同一地址），或进行先写后读操作，或进行先读后写操作

4. 广播、广集操作：一般而言，数据传送只在一个主方和一个从方之间进行。但有的总线允许一个主方对多个从方进行写操作，这种操作称为广播。与广播相反的操作称为广集，它将选定的多个从方数据在总线上完成AND或OR操作。

### HOST总线与PCI总线

![image-20200517153420886](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517153420886.png?raw=true)

HOST总线：

* 该总线有CPU总线、系统总线、主存总线、前端总线等多种名称，各自反映了总线功能的一个方面。这里称“宿主”总线，也许更全面，因为HOST总线不仅连接主存，还可以连接多个CPU。
* 它是连接“北桥”芯片与CPU之间的信息通路，它是一个64位数据线和32位地址线的同步总线。CPU拥有HOST总线的控制权，但在必要情况下可放弃总线控制权。

PCI总线：

* 连接各种高速的PCI设备。PCI是一个与处理器无关的高速外围总线。PCI设备可以是主设备，也可以是从设备，或兼而有之。

* 系统中允许有多条PCI总线，它们可以使用HOST桥与HOST总线相连，也可使用PCI/PCI桥与已和HOST总线相连的PCI总线相连，从而得以扩充PCI总线负载能力。
* PCI总线也是用集中仲裁的方式

LAGACY总线：

* 可以是ISA，EISA，MCA等这类性能较低的传统总线，以便充分利用市场上丰富的适配器卡，支持中、低速I/O设备。

在PCI总线体系结构中有三种桥（HOST桥，PCI/LAGACY总线桥，PCI/PCI桥）。其中HOST桥又是PCI总线控制器，含有中央仲裁器。

## 第七章 外围设备

### 基本概念

<img src="https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517153755179.png?raw=true" alt="image-20200517153755179" style="zoom:67%;" />

功能：在计算机和其他机器之间，以及计算机与用户之间提供联系

基本组成：存储介质、驱动装置、控制电路

五大外围设备：输入设备、输出设备、外存设备、数据通信设备和过程控制设备

### 磁盘上信息的分布

![image-20200517154003008](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517154003008.png?raw=true)

外存储器又称磁表面存储设备，磁盘存储器、磁带存储器均属于磁表面存储器。

磁盘上信息的分布：

（1）盘片的上下两面都能记录信息，通常把磁盘片表面称为记录面。

（2）记录面上一系列同心圆称为磁道。每个盘片表面通常有几百到几千个磁道。

（3）每个磁道又分为若干个扇区，如上图所示。从图中看出，外面扇区比里面扇区面积要大，但**存储的数据量相同**。

磁道的编址是**从外向内**依次编号，最外一个同心圆叫0磁道，最里面的一个同心圆叫n磁道，**n磁道里面的圆面积并不用来记录信息**。

扇区的编号有多种方法，可以连续编号，也可间隔编号。磁盘记录面经这样编址后，就可用**n磁道m扇区**的磁盘地址找到实际磁盘上与之相对应的记录区。

除了磁道号和扇区号之外，还有记录面的**面号**，以说明本次处理是在哪一个记录面上。例如对活动头磁盘组来说，磁盘地址是由**记录面号(也称磁头号)、磁道号和扇区号**三部分组成。

在磁道上，信息是按区存放的，每个区中存放一定数量的字或字节，各个区存放的字或字节数是相同的。

### 磁盘存储器的技术指标

#### 存储密度

存储密度分道密度、位密度和面密度。

* 道密度：沿磁盘半径方向单位长度上的磁道数，单位为道/英寸。

* 位密度：磁道单位长度上能记录的二进制代码位数，单位为位/英寸。

* 面密度：位密度和道密度的乘积，单位为位/平方英寸

#### 存储容量

一个磁盘存储器所能存储的字节总数，称为磁盘存储器的存储容量。

#### 数据传输率

磁盘存储器在单位时间内向主机传送数据的字节数，叫数据传输率。

假设磁盘旋转速度为`n`转/秒，每条磁道容量为`N`个字节(一圈，【**每条磁道不论长短，容量相同**】)；`D`为位密度(位/英寸)，`v`为磁盘旋转的线速度(英寸/秒)。则数据传输率：`Dr`=`n·N` 或`D·v` (字节/秒)

#### 平均存取时间

存取时间是指从发出读写命令后，磁头从某一起始位置移动至新的记录位置，到开始从盘片表面读出或写入信息加上传送数据所需要的时间。取决于以下三个因素决定：

1. 将磁头定位至所要求的磁道上所需的时间，称为**找道时间**；

2. 是找道完成后至磁道上需要访问的信息到达磁头下的时间，称为**等待时间**，这两个时间都是随机变化的，因此往往使用平均值来表示，**平均找道时间**是最大找道时间与最小找道时间的平均值。**平均等待时间**和磁盘转速有关，它用磁盘旋转一周所需时间的一半来表示。

   因此磁盘总的**平均存取时间Ta**可表示为

   <img src="https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517154744562.png?raw=true" alt="image-20200517154744562" style="zoom:50%;" />

   `Ts`:平均寻道时间，`1/2r`:平均等待时间，`b/(r·N)`:数据传送时间。
   `r`:磁盘旋转速率(转/秒)，`b`:传送的字节数，`N`:每磁道字节数，`r·N`为数据传输率(字节/秒)

3. 数据传送时间

#### 例题

磁盘组有`6`片磁盘，每片有`2`个记录面，**最上最下两个面不用**。存储区域内径`22cm`，外径`33cm`，道密度为`40道/cm`(径向)，内层位密度`400位/cm`（周长），转速`6000转/分`。问：

（1）共有多少柱面？（即每一片有多少磁道）

（2）盘组总存储容量是多少？

（3）数据传输率多少？

（4）采用定长数据块记录格式，直接寻址的最小单位是什么?寻址命令中如何表示磁盘地址？

（5）如果某文件长度超过一个磁道的容量，应将它记录在同一个存储面上，还是记录在同一个柱面上？

解答：

（1）有效存储区域：`33/2-22/2 = 16.5-11 = 5.5(cm)`

* 由`道密度=40道/cm`，所以`40×5.5 = 220(道)`，即`220`个圆柱面。

（2）内层磁道周长：`2πR = 2×3.14×11 = 69.08(cm)`

* 每道信息量：`400bit/cm × 69.08cm = 27632bit = 3454B`

  ——`内层位密度 * 内层磁道周长 `，由于“**每条磁道不论长短，容量相同**”，所以计算内层磁道的信息量即可得到每道信息量

* 每面信息量：`3454B × 220 = 759880B`

* 盘组总容量：`880B × 10 = 7598800B`

  ——`6`片磁盘，每片有`2`个记录面，**最上最下两个面不用**，所以共有`10`个盘面用于存储数据

（3）磁盘数据传输率`Dr = r·N`

* `N`为每条磁道容量，`N = 3454B`——由“**每条磁道不论长短，容量相同**”

* `r`为磁盘转速，`r = 6000转/60秒 = 100转/秒`

* `Dr = r·N = 100×3454B = 345400B/s`

（4）采用定长数据块格式，直接寻址的最小单位是一个记录块(一个扇区)，每个记录块记录固定字节数目的信息，在定长记录的数据块中，活动头磁盘组的编址方式可用如下图所示格式。*此地址格式表示有4台磁盘（2位, 17~16），每台有16个记录面/盘面（4位, 7~4），每面有256个磁道（8位, 15~8），每道有16个扇区（4位, 3~0）。*

![image-20200517160415160](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517160415160.png?raw=true)

（5）如果某文件长度超过一个磁道的容量，应将它记录在同一个柱面上，因为不需要重新找道，即磁头不需移动，数据读/写速度快。

### 显示器显存例题

例题：某CRT显示器可显示64种ASCII字符，每帧可显示64字符25排；字符字形采用7*8点阵，即横向7点，字间间隔1点，纵向8点，排间间隔6点；帧频50Hz，采取逐行扫描方式。问：

（1）缓存（VARM）容量有多大？ （每帧）

（2）缓存中存放的是ASCII代码还是点阵信息？

（3）缓存地址与屏幕显示位置如何对应？

解答：

（1）缓存容量为`64*25=1600(Byte)`。*——由“每帧可显示64字符25排”*

（2）缓存中存放的是待显示字符的ASCII代码。

（3）显示位置自左至右显示一行，再从上到下。相应地，缓存地址由低到高，每个地址码对应一个字符显示位置。



## 第八章 输入输出系统

### 基本概念

#### 接口的定义

为CPU和主存、I/O设备之间传送信息而设的转换逻辑部件。

#### 输入输出过程

输入过程： 

1. CPU送地址选择某一输入设备； 

2. CPU等候数据成为有效； 

3. CPU读入数据，存入相应的寄存器中。

输出过程： 

1. CPU送地址选择某一输出设备；
2. CPU把数据放在数据总线上； 
3. 输出设备取数据。

#### CPU与外设之间定时方式

与速度相关——若是速度极慢或简单的外设，采用直接交换。若是中速的外设，采用应答式交换，即异步定时方式。若是高速外设，采用同步定时方式。

#### 主机与外设信息交换方式

1. 直接程序控制方式

   CPU通过I/O指令对I/O设备进行访问，主机与外设交换信息的每一过程均在程序中表示出来，分为如下两类：

   * 立即程序传送方式：不询问外设状态，根据程序情况随时向外设传送数据。

   * 程序查询方式：根据外设的工作状态，在相应外设准备好时再向外设传送数据。

     优点：操作简单，缺点：CPU效率低。

2. 程序中断方式

   当有某些随机事件发生时CPU暂停执行当前的程序，转去执行引起中断的程序，处理完后再返回继续执行原程序。

   优点：CPU效率高；缺点：大批量传送速度慢。

3. DMA方式（直接内存访问）

   通过**硬件**控制总线，实现主存与I/O设备间的直接数据传送，在传送过程中无需CPU程序干预 。

   优点：CPU效率高，速度快，适合大批量数据传送；缺点：增加硬件，成本较高。

4. 通道方式

   通过执行通道（一种专用控制器）程序进行I/O操作的管理。也是由**硬件**来完成。

   通道的种类有：**选择通道**、**数组多路通道**、**字节多路通道**

#### 中断的概念

中断：当有某些随机事件发生时CPU暂停执行当前的程序，转去执行引起中断的程序，处理完后再返回继续执行原程序。

中断请求：中断源（分成**可屏蔽中断**和**非屏蔽中断**）请求CPU为自己服务的过程；

处理中断：（即运行中断服务子程序）保护现场，执行中断服务程序，恢复现场，开中断。

中断返回：恢复被中断程序处地址，继续执行原程序。

当CPU 响应中断时，**由硬件**直接产生一个固定的地址，即**向量地址**。由**向量地址**指出每个中断源设备的中断服务程序入口，此方法称为**向量中断**。

* 一级向量方式：地址码**直接对应**中断程序入口地址；
* 二级向量方式：地址码**经转换**后得到中断程序入口地址。

### 单级多级中断

单级中断：所有中断优先级相同，一旦响应一个中断后，只有服务完才可响应其他中断。

* 系统结构：公共请求线方式。
* 断源识别方式：链式查询方式。
* 查询顺序决定优先级。

多级中断：系统中的多个中断源**具有不同的优先级**。低优先级中断处理过程中**可以被高优先级的中断源打断**，实现**中断嵌套**。在下图中，**当IR=1且IM=0时**，该级中断请求进入排队电路等待响应中断响应后，由硬件直接修改各级IM的值，保证相应次序，将本级和优先级低于本级的IM设为1，将更高级的IM设为0

![image-20200517163801948](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517163801948.png?raw=true)

* 在多级中断之间可以实现中断嵌套，但在**同一级不可以嵌套**；
* 由**中断堆栈**，按顺序保护现场。 
* 每级中断，CPU中都有请求触发器IR，及屏蔽触发器IM
* 中断响应优先顺序由硬件设定

#### 例题1

如上图在各设备同时提出中断请求的情况下

（1）各个设备的优先级如何？`A→B→C→D→E→F→G→H→I `

（2）若CPU执行设备D的服务子程序，IM2，IM1，IM0的状态又是什么？`IM2-0：0 1 1`

#### 例题2

某计算机有四级中断，优先级从高到低为`A>B>C>D`。假定各级中断程序的屏蔽位设置为`A:1101, B:0100, C:1111, D:0101` 。请给出中断处理次序。设A,B,C,D同时请求中断，试画出CPU执行程序的轨迹。

中断处理次序：C>A>D>B

![image-20200517164422843](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517164422843.png?raw=true)

#### 例题3

某计算机系统共有五级中断，其中断响应优先级从高到低为`1→2→3→4 →5`。现按如下规定修改：各级中断处理时均屏蔽本级中断，且处理1级中断时屏蔽2、3、4和5级中断；处理2级中断时屏蔽3、4、5级中断；处理4级中断时不屏蔽其他级中断；处理3级中断时屏蔽4级和5级中断；处理5级中断时屏蔽4级中断。试问中断处理优先级(从高到低)顺序如何排列？并给出各级中断处理程序的中断屏蔽字？（设“0”为允许，“1”为禁止。）

解：实际中断处理优先级(从高到低)顺序应为`1→2→3→5→4`

| 中断级数 | 中断屏蔽字 |
| -------- | ---------- |
| 1        | 11111      |
| 2        | 01111      |
| 3        | 00111      |
| 4        | 00010      |
| 5        | 00011      |



### DMA控制器

DMA的基本工作处理过程

* DMA请求：外设通过接口向 CPU 发DMA请求信号。

* DMA响应：CPU将工作改为DMA操作方式，将总线控制权交给DMA控制器。

* DMA数据传送：DMA控制器发总线信号，在主存和I/O 寄存器 之间传送数据。
* 结束处理：数据传送完后，发中断请求，通知CPU进行后处理。

分为：选择型和多路型

1. 选择型DMA控制器： DMA控制逻辑与I/O接口合并为一个整体，并可通过设备选择逻辑控制多台I/O设备，但逻辑上只允许连接一个设备；

2. 多路型DMA控制器：DMA控制逻辑公用部分与I/O接口分离，形成专用DMA控制器。多路型可同时控制多个设备工作。当多个外设同时发DMA请求时，根据判优逻辑响应优先级高的请求。

#### 例题

图中假设有磁盘、磁带、打印机三个设备同时工作。磁盘以30μs的间隔向控制器发DMA请求，磁带以45μs的间隔发DMA请求，打印机以150μs间隔发DMA请求。根据传输速率，磁盘优先权最高，磁带次之，打印机最低，图中假设DMA控制器每完成一次DMA传送所需的时间是5μs。若采用多路型DMA控制器，请画出DMA控制器服务三个设备的工作时间图。

![image-20200517164947045](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517164947045.png?raw=true)

![image-20200517164953255](https://github.com/Littlefisher619/fzu-notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/img/image-20200517164953255.png?raw=true)



## 第九章

（略，不考）



## 第十章 实验内容

（略）

